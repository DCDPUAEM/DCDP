# -*- coding: utf-8 -*-
"""Practica3_Pandas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/RosalesRM/c5ab201e07c690d83c35fa30bf41dfe0/practica3_pandas.ipynb

# Analizando las estadísticas de jugadores de futbol con Pandas

![FIFA](https://upload.wikimedia.org/wikipedia/commons/thumb/a/aa/FIFA_logo_without_slogan.svg/1200px-FIFA_logo_without_slogan.svg.png)

En esta notebook, utilizarás Pandas para analizar datos de jugadores de futbol (soccer). Los datos se encuentran en forma tabular e incluyen información relevante de jugadores de futbol de todo el mundo.

---


Cada fila en el conjunto de datos contiene información sobre el jugador:
* Información personal: Nombre, nacionalidad, , edad, altura, peso y pierna preferida al jugar.
* Información como jugador: Nombre del equipo en el que juega (Club), número de playera, posición en el campo (abreviada), valor comercial y salario.
* Información sobre sus habilidades como jugador (0-100): Overall, Potential, Shooting, Defense, Passing, Physical, Control, Mental y GoalKeeping.


Durante la notebook llevarás a cabo tareas de tratamiento y análisis exploratorio de datos comunmente realizadas. Buscarás información que podría resultar útil para las organizaciones.



---



Recuerda que puedes acudir a la [documentación de Pandas](https://pandas.pydata.org/pandas-docs/stable/reference/index.html) o a la notebook de Pandas del diplomado en ciencia de datos.

Primero, importa Pandas en tu notebook:
"""

# pandas usando el alias pd
import pandas as pd

"""Ejecuta la siguiente celda para cargar el conjunto de datos desde el repositorio en github a la máquina en colab."""

# Fetch the dataset using the raw GitHub URL.
!curl --remote-name \
     -H 'Accept: application/vnd.github.v3.raw' \
     --location https://raw.githubusercontent.com/DCDPUAEM/DCDP/main/01%20Programaci%C3%B3n%20en%20Python/data/fifa/players.csv

"""Veamos las primeras líneas del archivo usando un comando de linux en la celda de colab:"""

!head -n 5 players.csv

"""## Carga el conjunto de datos FIFA usando pandas"""

# leer el dataframe usando read_csv
fifa_df = pd.read_csv("players.csv", sep=',', header=0)
# mostrar los primeros elementos con head
fifa_df.head()

"""## Características del dataset

¿Qué tipos de datos contiene nuestro dataframe?
"""

for name, t in zip(fifa_df.columns, fifa_df.dtypes):
  print(name, t)

"""¿Qué tamaño tiene nuestro dataset?

Utiliza el método ```shape``` para conocer el número de filas y columnas en el dataframe.
"""

m,n = fifa_df.shape
print("Filas:", m)
print("Columnas:", n)

assert m == 18207 and n == 21, "Error en las dimensiones"

"""### Estadísticas generales del dataset.

Usa ```describre()``` para mostrar las estadísticas generales de las columnas numéricas en el dataframe.
"""

fifa_df.describe()

"""## Tratamiento de datos

### Datos faltantes

Antes de poder hacer transformaciones y operaciones en los datos, es importante identificar la posible existencia de datos faltantes. El método ```isna()``` de pandas, permite obtener un dataframe booleano que identifica entradas faltantes.

Usémos ```isna()```, ```sum(axis=0)``` y ```to_frame().T``` para resumir el resultado de datos faltantes como un conteo por columnas:
"""

fifa_df.isna().sum(axis=0).to_frame().T

"""Una manera de tratar con datos faltantes, es eliminar las filas que contienen uno o más datos faltantes, dejando solo registros completos.

Ya que para nuestro conjunto de datos la cantidad de faltantes es mínima, podemos usar esta estrategia.

Completa la siguiente celda para eliminar filas (```axis=0```) que contengan algún dato faltante (```dropna```):
"""

fifa_df.columns

t_df = fifa_df.dropna(axis=0)

"""Verifica que no hay más datos faltantes:"""

empty_columns = t_df.isna().sum(axis=0).to_frame().T
empty_columns

assert empty_columns.values.sum() == 0, "Error, aun hay datos faltantes"

"""Finalmente, reemplazar el dataframe original por el nuevo sin elementos faltantes."""

fifa_df = t_df

"""### Transformaciones

Las celdas fueron inferidas como tipo ```object``` por pandas. Algunas de éstas contienen datos numéricos que podrían ser útiles para el análisis.

Por ejemplo, las columnas ```Wage``` y ```Value``` contienen datos sobre el salario y el valor en el mercado de cada jugador. Ambas columnas contienen el signo de la moneda (€) al inicio y al final pueden contener la abreviación de cantidades (K miles, M millones).

Debemos realizar un tratamiento de datos en tales columnas para poder usarlas de manera numérica.

Primero, confirmemos que solo tenemos casos donde las cantidades terminan en K, M o sin abreviaturas. Usemos funciones de agregación.

Contemos las veces que aparecen los distintos caracteres al final de los registros en la columna ```Wage```:
"""

fifa_df[["Wage"]].groupby(fifa_df.Wage.str[-1]).count()

"""Contemos las veces que aparecen los distintos caracteres al final de los registros en la columna ```Value```:"""

fifa_df[["Value"]].groupby(fifa_df.Value.str[-1]).count()

def currency_to_numeric(currency):
    """
    La funcion recibe valores monetarios en un objeto de texto, los tranforma:
    1- Elimina el simbolo de la moneda al inicio de la cadena
    2- Extrae el caracter adicional al final de la cadena que indica el
       multiplo de la cantidad (abreviatura). No siempre hay un simbolo.
    3- Usa el valor para devolver la cantidad en numero (multiplica por el valor).
    Ej: 250K pasa a 250000
    ya que
    1K = 1000
    1M = 1000000
    Sin letra solo parte numerica
    """
    # el multiplo de K o M
    symbols = {"K": 1000, "M": 1000000}
    # Actualiza el valor de numeric con la cantidad en currency
    numeric = 0.0

    # Eliminar el símbolo de la moneda al inicio de la cadena
    currency = currency.lstrip("$€")  # Agrega más símbolos según sea necesario

    # Extraer el caracter adicional al final de la cadena (si existe)
    multiplier = 1
    if currency[-1] in symbols:
        multiplier = symbols[currency[-1]]
        currency = currency[:-1]

    # Convertir la parte numerica a float y multiplicarla por el multiplicador
    numeric = float(currency) * multiplier

    return numeric

# Prueba de la función
print(currency_to_numeric("$250K"))  # Debería imprimir 250000.0

"""Prueba tu función:"""

currency_to_numeric("$20")

assert currency_to_numeric("$20") == 20.0 and currency_to_numeric("$50K") == 50*10.0**3 and currency_to_numeric("$10M") == 10*10.0**6, "Error"

"""Cambia las columnas ```Wage``` y ```Value``` a numéricos usando ```currency_to_numeric``` elemento por elemento con ```applymap```:"""

fifa_df[["Wage", "Value"]] = fifa_df[["Wage", "Value"]].applymap(currency_to_numeric)
fifa_df.head()

"""### Suplementando la información

En el set de datos, tenemos una columna ```Position``` que indica la posición en la que el jugador se desempeña en el campo. Algo que podrás notar, es que originalmente la posición está de manera abreviada, si no conoces las abreviaturas, será complicado saber en qué posición juega cada jugador.


Para solucionar esto, usémos otro set de datos para cambiar de abreviatura a algo más descriptivo, pero manteniendo la abreviatura.

La siguiente imágen muestra las posiciónes más comunes en el campo:
![Posiciones de juego](https://raw.githubusercontent.com/jhermosillo/DIPLOMADO_CDP/main/01%20Programaci%C3%B3n%20en%20Python/images/SoccerFieldPositions.png)

Vamos a utilizar un nuevo set de datos que contiene la abreviatura de cada posición (```Abbreviation```) y su significado (```Full```).

Carga el archivo desde github a colab con la siguiente celda:
"""

# Fetch the dataset using the raw GitHub URL.
!curl --remote-name \
     -H 'Accept: application/vnd.github.v3.raw' \
     --location https://raw.githubusercontent.com/DCDPUAEM/DCDP/main/01%20Programaci%C3%B3n%20en%20Python/data/fifa/positions.csv

"""Ejecuta la siguiente celda para crear y ver el nuevo dataframe con los datos de las posiciones:"""

positions_df = pd.read_csv("positions.csv", header=0, skipinitialspace=True)
positions_df.head()

"""Utiliza el nuevo dataframe para actualizar la columna ```Position``` en el dataframe de jugadores por la posición descriptiva + abreviada.

Primero, debemos de *unir* ambos dataframes, ambos comparten una columna (pero tienen diferentes nombre) la posición abreviada.

Utiliza un método de pandas para unir el dataframe ```fifa_df``` con ```positions_df```.

*Tip: Queremos unir cada fila de la **izquierda** (cada jugador) con una sola fila de la **derecha** (su posición completa en el campo).*
"""

merged_df = fifa_df.merge(positions_df, left_on="Position", right_on="Abbreviation")

merged_df.head()

assert len(merged_df.columns) == 23, "Error"
print("La union de ambos dataframes contiene ", len(merged_df.columns), " columnas")

"""Usemos la nueva columna ```Full``` para actualizar la columna ```Position``` para que contenga el significado y abreviatura de la posición:

```merged_df["Full"] + " (" + merged_df["Position"] +")"```
"""

merged_df["Position"] = merged_df["Full"] + " (" + merged_df["Position"] +")"

"""Muestra la columna actualizada:"""

merged_df["Position"].head(3)

"""Ahora, tenemos algunas columnas adicionales que ya no son útiles.

Eliminemos las columnas ```Abbreviation``` y ```Full``` del dataframe usando ```drop()```:
"""

merged_df = merged_df.drop(["Abbreviation", "Full"], axis=1)

merged_df.head(3)

assert len(merged_df.columns) == 21, "Error"

"""Asignemos al dataframe original ```fifa_df``` el nuevo dataframe con el tratamiento de datos ya realizado:"""

fifa_df = merged_df
fifa_df.head()

"""## Análisis exploratorio

En esta sección, utilizarás distintos métodos de los dataframes de pandas para generar un análisis exploratorio. En un análisis exploratorio, se busca explorar, resumir y entender los datos.

### Jugadores con el mayor valor comercial y jugadores mejores pagados

Muestra el **Top 3** de jugadores con mayor valor (```Value```) en el mercado.
"""

# Ordenar el DataFrame por el salario ('Wage') en orden descendente y seleccionar los primeros 3 jugadores
top_salario = fifa_df.nlargest(3, 'Value')
top_salario

top_valor = fifa_df.sort_values(by='Value', ascending=False).head(3)
top_valor

"""Muestra el **Top 3** de jugadores mejores pagados en el mundo (Salarios más altos, ```Wage```)."""

top_valor = fifa_df.sort_values(by='Wage', ascending=False).head(3)
top_valor

"""### Potencial por alcanzar

Utiliza operaciones Crea una nueva columna que  muestre el potencial por alcanzar ```Potential left``` de cada jugador en el conjunto de datos. El potencial por alcanzar puede ser calculado mediante ```Potential - Overall```.
"""

fifa_df["Potential left"] = fifa_df["Potential"] - fifa_df["Overall"]
fifa_df.head()

"""### Jóvenes promesa

Utiliza las funciones de Pandas para encontrar el **top 5** de jugadores "promesa" menores de 22 años. Ordena ascendentemente el dataframe según el potencial (```Potential```), potencial por alcanzar (```Potential left```) y su nivel (```Overall ```) actual.
"""

# Filtrar los jugadores menores de 22 años
# Condición para "filtro" de datos que cumpla la condición < 22
jugadores_promesa = fifa_df[fifa_df['Age'] < 22]

# Ordenar los jugadores promesa por potencial (Potential), potencial por alcanzar (Potential left) y su nivel actual (Overall)
top_promesa = jugadores_promesa.sort_values(by=['Potential', 'Potential left', 'Overall'], ascending=[True, True, True])

# Seleccionar los primeros 5 jugadores
top5_promesa = top_promesa.head(5)

# Imprimir el top 5 de jugadores promesa
print("Top 5 de jugadores promesa menores de 22 años:")
print(top5_promesa[['Name', 'Age', 'Potential', 'Potential left', 'Overall']])

"""### Mejor defensa en el mundo

Encuentra al jugador con el mayor puntaje en la columna ```Defense```:

*Tip: utiliza el método ```idxmax``` para encontrar la fila donde se encuentra el mejor defensa. Después usa el índice para acceder a los datos de la fila.*
"""

# Suponiendo que tienes un DataFrame llamado 'fifa_df' que contiene los datos de los jugadores

# Utiliza idxmax para encontrar el índice del jugador con el mejor puntaje en la columna 'Defense'
indice_mejor_defensa = fifa_df['Defense'].idxmax()

# Accede a los datos del jugador con el mejor puntaje en 'Defense' utilizando el índice obtenido
mejor_defensa = fifa_df.loc[indice_mejor_defensa]

# Imprime la información del mejor defensa en el mundo
print("Mejor defensa en el mundo:")
print(mejor_defensa[['Name', 'Club', 'Defense', 'Position']])

"""### Porcentaje pie preferido

Calcula el porcentaje mundial de jugadores que prefieren utilizar su pierna derecha para controlar el balón y el porcentaje que prefiere utilizar la pierna izquierda.

*Tip: El método ```value_counts()``` de objetos Series podría resultarte particularmente útil para esta tarea.*
"""

# Calcula el conteo de jugadores por cada valor único en la columna 'Preferred Foot'
conteo_pie_pref = fifa_df['Preferred Foot'].value_counts()

# Calcula el porcentaje de jugadores que prefieren utilizar su pierna derecha e izquierda
porcentaje_derecha = (conteo_pie_pref['Right'] / fifa_df.shape[0]) * 100
porcentaje_izquierda = (conteo_pie_pref['Left'] / fifa_df.shape[0]) * 100

# Imprime los resultados
print("Porcentaje de jugadores que prefieren la pierna derecha: {:.2f}%".format(porcentaje_derecha))
print("Porcentaje de jugadores que prefieren la pierna izquierda: {:.2f}%".format(porcentaje_izquierda))

"""### Equipos con mayor talento promedio

Utiliza funciones de agregación y de agrupamiento para obtener a los equipos con el mejor promedio de nivel (```Overall```) entre sus jugadores.
"""

# Calcula el promedio de nivel (Overall) para cada equipo
promedio_por_equipo = fifa_df.groupby('Club')['Overall'].mean()

# Ordena los equipos por el promedio de nivel (Overall) en orden descendente
mejores_equipos = promedio_por_equipo.sort_values(ascending=False)

# Muestra los mejores equipos con su promedio de nivel
print("Equipos con el mejor promedio de nivel (Overall):")
print(mejores_equipos.head())

"""### Equipos con más costosos (valor comercial)

Utiliza funciones de agregación y agrupamiento para encontrar el valor total de de cada club, esto es, la suma de los valores individuales de los jugadores de los Club.

Ordena de manera descendente para mostrar los clubs más costosos del mundo.
"""

# Calcula el valor comercial total de cada club sumando los valores individuales de los jugadores
valor_comercial_por_equipo = fifa_df.groupby('Club')['Value'].sum()

# Ordena los equipos por valor comercial total en orden descendente
equipos_mas_costosos = valor_comercial_por_equipo.sort_values(ascending=False)

# Muestra los equipos más costosos con su valor comercial total
print("Equipos más costosos del mundo por valor comercial total:")
print(equipos_mas_costosos.head())

"""### ¿Qué equipos tienen más mexicanos?

Muestra un top 5 de equipos con más jugadores mexicanos en el mundo.

Primero, crea un dataframe que contiene unicamente jugadores mexicanos:

*Tip: Filtra el dataframe usando ```Nationality==Mexico```*.
"""

# Filtra el DataFrame para incluir solo jugadores mexicanos
jugadores_mexicanos = fifa_df[fifa_df['Nationality'] == 'Mexico']

# Calcula el número de jugadores mexicanos en cada equipo
jugadores_por_equipo = jugadores_mexicanos['Club'].value_counts()

# Muestra un top 5 de equipos con más jugadores mexicanos en el mundo
top_equipos_mexicanos = jugadores_por_equipo.head(5)

print("Top 5 de equipos con más jugadores mexicanos en el mundo:")
print(top_equipos_mexicanos)

"""Agrupa por el nombre del club y cuenta:

"""

# Filtra el DataFrame para incluir solo jugadores mexicanos
jugadores_mexicanos = fifa_df[fifa_df['Nationality'] == 'Mexico']

# Agrupa por el nombre del club y cuenta la cantidad de jugadores mexicanos en cada uno
jugadores_por_club = jugadores_mexicanos.groupby('Club').size()

# Muestra el número de jugadores mexicanos por club
print("Número de jugadores mexicanos por club:")
print(jugadores_por_club)

"""## Visualización

Utiliza las opciones de visualización de Pandas.

### Histograma de las edades de los jugadores de futbol

Selecciona la columna ``Age``` del dataframe ```fifa_df``` y muestra el histograma usando las opciones de visualización de Pandas:
"""

# Suponiendo que tienes un DataFrame llamado 'fifa_df' que contiene los datos de los jugadores
import matplotlib.pyplot as plt

# Muestra el histograma de las edades de los jugadores usando Pandas
fifa_df['Age'].plot.hist(bins=10)

# Agrega etiquetas y título al histograma
plt.title('Histograma de las Edades de los Jugadores de Fútbol')
plt.xlabel('Edad')
plt.ylabel('Frecuencia')

# Muestra el histograma
plt.show()

"""### Gráfica de Pie (Preferred Foot)

Selecciónes el conteo de valores del pie preferido (columna ```Preferred Foot```) y muestra la información mediante una gráfica de Pie:
"""

# Calcula el conteo de valores en la columna 'Preferred Foot'
conteo_pie_pref = fifa_df['Preferred Foot'].value_counts()

# Muestra la información en una gráfica de pie
conteo_pie_pref.plot.pie(autopct='%1.1f%%', colors=['lightblue', 'lightgreen'], startangle=140)

# Agrega título a la gráfica
plt.title('Preferencia de Pie de los Jugadores')

# Muestra la gráfica de pie
plt.axis('equal')  # Para asegurarse de que la gráfica de pie sea un círculo
plt.show()

"""### Gráfica de dispersión Edad vs Potential left

Ahora, utiliza una gráfica de dispersión para visualizar el comportamiento del potencial por alcanzar (```Potential left```) de acuerdo a las edades de los jugadores:

*Tip: La gráfica debe mostrar la edad en un eje y el potencial por alcanzar en el otro.*
"""

# Gráfica de dispersión Edad vs Potential left
fifa_df.plot.scatter(x='Age', y='Potential left', figsize=(10, 6), color='blue')

# Título y etiquetas de los ejes
plt.title('Edad vs Potential left de los jugadores de futbol')
plt.xlabel('Edad')
plt.ylabel('Potential left')

# Mostrar la gráfica
plt.show()

"""¿Qué otras variables o mezcla de variables sería interesante visualizar?

# Desafío Adicional

En la práctica con Numpy, creaste un modelo para identificar imágenes de dígitos escritos a mano.

Para este nuevo conjunto de datos, ¿podrías usar una metodología similar para encontrar la posición en el campo de un jugador solamente usando los valores de su habilidades?

Skills: ```Shooting 	Defense 	Passing 	Physical 	Control 	Mental 	GoalKeeping```
"""

from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import StandardScaler

# Seleccionar características relevantes
features = ["Shooting", "Defense", "Passing", "Physical", "Control", "Mental", "GoalKeeping"]
X = fifa_df[features]
y = fifa_df["Position"]

# Dividir los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Normalizar las características
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Entrenar el clasificador k-NN
knn_classifier = KNeighborsClassifier(n_neighbors=5)
knn_classifier.fit(X_train_scaled, y_train)

# Evaluar el modelo utilizando validación cruzada
cv_scores = cross_val_score(knn_classifier, X_train_scaled, y_train, cv=5)
print("Accuracy utilizando validación cruzada:", cv_scores.mean())

# Predicción de nuevas instancias
# Supongamos que tenemos un nuevo jugador con las siguientes habilidades
new_player_skills = [[70, 65, 75, 80, 85, 70, 60]]  # Por ejemplo

# Escalar las características del nuevo jugador
new_player_skills_scaled = scaler.transform(new_player_skills)

# Predecir la posición del nuevo jugador
predicted_position = knn_classifier.predict(new_player_skills_scaled)
print("La posición predicha del nuevo jugador es:", predicted_position)

import numpy as np

# Función para calcular la distancia euclidiana entre dos vectores
def euclidean_distance(p1, p2):
    return np.sqrt(np.sum((p1 - p2) ** 2))

# Habilidades de los jugadores representativos de cada posición
representatives = {
    "Forward": np.array([90, 30, 80, 70, 90, 60, 10]),
    "Midfielder": np.array([70, 60, 90, 80, 85, 75, 20]),
    "Defender": np.array([50, 80, 70, 90, 70, 70, 30]),
    "Goalkeeper": np.array([20, 70, 40, 60, 60, 50, 90])
}

# Habilidades del nuevo jugador (por ejemplo)
new_player_skills = np.array([80, 40, 70, 75, 80, 65, 15])

# Calcular la distancia euclidiana entre el nuevo jugador y los jugadores representativos de cada posición
distances = {position: euclidean_distance(new_player_skills, skills) for position, skills in representatives.items()}

# Obtener la posición con la menor distancia euclidiana
predicted_position = min(distances, key=distances.get)

print("La posición predicha del nuevo jugador es:", predicted_position)

